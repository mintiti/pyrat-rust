from collections.abc import Iterator

class Coordinates:
    x: int
    y: int

    def __init__(self, x: int, y: int) -> None: ...
    def get_neighbor(self, direction: int) -> Coordinates: ...
    def is_adjacent_to(self, other: Coordinates) -> bool: ...
    def manhattan_distance(self, other: Coordinates) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __getitem__(self, index: int) -> int: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __add__(self, other: tuple[int, int] | int) -> Coordinates: ...
    def __sub__(self, other: Coordinates | tuple[int, int]) -> tuple[int, int]: ...

class Wall:
    pos1: Coordinates
    pos2: Coordinates

    def __init__(
        self,
        pos1: Coordinates | tuple[int, int],
        pos2: Coordinates | tuple[int, int],
    ) -> None: ...
    def blocks_movement(self, from_pos: Coordinates, to_pos: Coordinates) -> bool: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __iter__(self) -> Iterator[Coordinates]: ...
    def __len__(self) -> int: ...

class Mud:
    pos1: Coordinates
    pos2: Coordinates
    value: int

    def __init__(
        self,
        pos1: Coordinates | tuple[int, int],
        pos2: Coordinates | tuple[int, int],
        value: int,
    ) -> None: ...
    def affects_movement(self, from_pos: Coordinates, to_pos: Coordinates) -> bool: ...
    def blocks_movement(self, from_pos: Coordinates, to_pos: Coordinates) -> bool: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __iter__(self) -> Iterator[Coordinates | int]: ...
    def __len__(self) -> int: ...
