from pyrat_engine._core.observation import PyGameObservation
from pyrat_engine._core.types import Coordinates, Mud, Wall

class PyMoveUndo:
    @property
    def p1_pos(self) -> Coordinates: ...
    @property
    def p2_pos(self) -> Coordinates: ...
    @property
    def p1_target(self) -> Coordinates: ...
    @property
    def p2_target(self) -> Coordinates: ...
    @property
    def p1_mud(self) -> int: ...
    @property
    def p2_mud(self) -> int: ...
    @property
    def p1_score(self) -> float: ...
    @property
    def p2_score(self) -> float: ...
    @property
    def p1_misses(self) -> int: ...
    @property
    def p2_misses(self) -> int: ...
    @property
    def collected_cheese(self) -> list[Coordinates]: ...
    @property
    def turn(self) -> int: ...

class PyRat:
    def __init__(
        self,
        width: int | None = None,
        height: int | None = None,
        cheese_count: int | None = None,
        symmetric: bool = True,
        seed: int | None = None,
        max_turns: int | None = None,
        wall_density: float | None = None,
        mud_density: float | None = None,
    ) -> None: ...
    @staticmethod
    def create_preset(
        preset: str = "default",
        *,
        seed: int | None = None,
    ) -> PyRat: ...
    @staticmethod
    def create_custom(
        width: int,
        height: int,
        walls: list[Wall] | list[tuple[tuple[int, int], tuple[int, int]]] = [],
        mud: list[Mud] | list[tuple[tuple[int, int], tuple[int, int], int]] = [],
        cheese: list[Coordinates] | list[tuple[int, int]] = [],
        player1_pos: Coordinates | tuple[int, int] | None = None,
        player2_pos: Coordinates | tuple[int, int] | None = None,
        max_turns: int = 300,
        symmetric: bool = True,
    ) -> PyRat: ...
    @staticmethod
    def create_from_maze(
        width: int,
        height: int,
        walls: list[Wall] | list[tuple[tuple[int, int], tuple[int, int]]],
        *,
        seed: int | None = None,
        max_turns: int = 300,
        symmetric: bool = True,
    ) -> PyRat: ...
    @staticmethod
    def create_from_walls(
        width: int,
        height: int,
        walls: list[Wall],
        *,
        seed: int | None = None,
        max_turns: int = 300,
        symmetric: bool = True,
    ) -> PyRat: ...
    @staticmethod
    def create_with_starts(
        width: int,
        height: int,
        player1_start: Coordinates | tuple[int, int],
        player2_start: Coordinates | tuple[int, int],
        *,
        preset: str = "default",
        seed: int | None = None,
    ) -> PyRat: ...
    @property
    def width(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def turn(self) -> int: ...
    @property
    def max_turns(self) -> int: ...
    @property
    def player1_position(self) -> Coordinates: ...
    @property
    def player2_position(self) -> Coordinates: ...
    @property
    def player1_score(self) -> float: ...
    @property
    def player2_score(self) -> float: ...
    @property
    def player1_mud_turns(self) -> int: ...
    @property
    def player2_mud_turns(self) -> int: ...
    def cheese_positions(self) -> list[Coordinates]: ...
    def mud_entries(self) -> list[Mud]: ...
    def wall_entries(self) -> list[Wall]: ...
    def get_valid_moves(self, pos: Coordinates | tuple[int, int]) -> list[int]: ...
    def effective_actions(self, pos: Coordinates | tuple[int, int]) -> list[int]: ...
    def effective_actions_p1(self) -> list[int]: ...
    def effective_actions_p2(self) -> list[int]: ...
    def step(self, p1_move: int, p2_move: int) -> tuple[bool, list[Coordinates]]: ...
    def make_move(self, p1_move: int, p2_move: int) -> PyMoveUndo: ...
    def unmake_move(self, undo: PyMoveUndo) -> None: ...
    def reset(self, seed: int | None = None) -> None: ...
    def get_observation(self, is_player_one: bool) -> PyGameObservation: ...
