// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod pyrat {

    #[allow(unused_imports, dead_code)]
    pub mod protocol {

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_DIRECTION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_DIRECTION: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_DIRECTION: [Direction; 5] = [
            Direction::Up,
            Direction::Right,
            Direction::Down,
            Direction::Left,
            Direction::Stay,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct Direction(pub u8);
        #[allow(non_upper_case_globals)]
        impl Direction {
            pub const Up: Self = Self(0);
            pub const Right: Self = Self(1);
            pub const Down: Self = Self(2);
            pub const Left: Self = Self(3);
            pub const Stay: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Up, Self::Right, Self::Down, Self::Left, Self::Stay];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Up => Some("Up"),
                    Self::Right => Some("Right"),
                    Self::Down => Some("Down"),
                    Self::Left => Some("Left"),
                    Self::Stay => Some("Stay"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for Direction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for Direction {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for Direction {
            type Output = Direction;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for Direction {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for Direction {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for Direction {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PLAYER: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PLAYER: u8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PLAYER: [Player; 2] = [Player::Rat, Player::Python];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct Player(pub u8);
        #[allow(non_upper_case_globals)]
        impl Player {
            pub const Rat: Self = Self(0);
            pub const Python: Self = Self(1);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 1;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Rat, Self::Python];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Rat => Some("Rat"),
                    Self::Python => Some("Python"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for Player {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for Player {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for Player {
            type Output = Player;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for Player {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for Player {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for Player {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TIMING_MODE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TIMING_MODE: u8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TIMING_MODE: [TimingMode; 2] = [TimingMode::Wait, TimingMode::Clock];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TimingMode(pub u8);
        #[allow(non_upper_case_globals)]
        impl TimingMode {
            pub const Wait: Self = Self(0);
            pub const Clock: Self = Self(1);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 1;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Wait, Self::Clock];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Wait => Some("Wait"),
                    Self::Clock => Some("Clock"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for TimingMode {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for TimingMode {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for TimingMode {
            type Output = TimingMode;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for TimingMode {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for TimingMode {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for TimingMode {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_GAME_RESULT: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_GAME_RESULT: u8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_GAME_RESULT: [GameResult; 3] =
            [GameResult::Rat, GameResult::Python, GameResult::Draw];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct GameResult(pub u8);
        #[allow(non_upper_case_globals)]
        impl GameResult {
            pub const Rat: Self = Self(0);
            pub const Python: Self = Self(1);
            pub const Draw: Self = Self(2);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Rat, Self::Python, Self::Draw];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Rat => Some("Rat"),
                    Self::Python => Some("Python"),
                    Self::Draw => Some("Draw"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for GameResult {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for GameResult {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for GameResult {
            type Output = GameResult;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for GameResult {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for GameResult {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for GameResult {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_OPTION_TYPE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_OPTION_TYPE: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_OPTION_TYPE: [OptionType; 5] = [
            OptionType::Check,
            OptionType::Spin,
            OptionType::Combo,
            OptionType::String,
            OptionType::Button,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct OptionType(pub u8);
        #[allow(non_upper_case_globals)]
        impl OptionType {
            pub const Check: Self = Self(0);
            pub const Spin: Self = Self(1);
            pub const Combo: Self = Self(2);
            pub const String: Self = Self(3);
            pub const Button: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Check,
                Self::Spin,
                Self::Combo,
                Self::String,
                Self::Button,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Check => Some("Check"),
                    Self::Spin => Some("Spin"),
                    Self::Combo => Some("Combo"),
                    Self::String => Some("String"),
                    Self::Button => Some("Button"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for OptionType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for OptionType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for OptionType {
            type Output = OptionType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for OptionType {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for OptionType {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for OptionType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_HOST_MESSAGE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_HOST_MESSAGE: u8 = 8;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_HOST_MESSAGE: [HostMessage; 9] = [
            HostMessage::NONE,
            HostMessage::SetOption,
            HostMessage::MatchConfig,
            HostMessage::StartPreprocessing,
            HostMessage::TurnState,
            HostMessage::Stop,
            HostMessage::Timeout,
            HostMessage::GameOver,
            HostMessage::Ping,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct HostMessage(pub u8);
        #[allow(non_upper_case_globals)]
        impl HostMessage {
            pub const NONE: Self = Self(0);
            pub const SetOption: Self = Self(1);
            pub const MatchConfig: Self = Self(2);
            pub const StartPreprocessing: Self = Self(3);
            pub const TurnState: Self = Self(4);
            pub const Stop: Self = Self(5);
            pub const Timeout: Self = Self(6);
            pub const GameOver: Self = Self(7);
            pub const Ping: Self = Self(8);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 8;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::SetOption,
                Self::MatchConfig,
                Self::StartPreprocessing,
                Self::TurnState,
                Self::Stop,
                Self::Timeout,
                Self::GameOver,
                Self::Ping,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::SetOption => Some("SetOption"),
                    Self::MatchConfig => Some("MatchConfig"),
                    Self::StartPreprocessing => Some("StartPreprocessing"),
                    Self::TurnState => Some("TurnState"),
                    Self::Stop => Some("Stop"),
                    Self::Timeout => Some("Timeout"),
                    Self::GameOver => Some("GameOver"),
                    Self::Ping => Some("Ping"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for HostMessage {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for HostMessage {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for HostMessage {
            type Output = HostMessage;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for HostMessage {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for HostMessage {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for HostMessage {}
        pub struct HostMessageUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BOT_MESSAGE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BOT_MESSAGE: u8 = 7;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BOT_MESSAGE: [BotMessage; 8] = [
            BotMessage::NONE,
            BotMessage::Identify,
            BotMessage::Ready,
            BotMessage::PreprocessingDone,
            BotMessage::Action,
            BotMessage::Pong,
            BotMessage::Info,
            BotMessage::RenderCommands,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BotMessage(pub u8);
        #[allow(non_upper_case_globals)]
        impl BotMessage {
            pub const NONE: Self = Self(0);
            pub const Identify: Self = Self(1);
            pub const Ready: Self = Self(2);
            pub const PreprocessingDone: Self = Self(3);
            pub const Action: Self = Self(4);
            pub const Pong: Self = Self(5);
            pub const Info: Self = Self(6);
            pub const RenderCommands: Self = Self(7);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 7;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Identify,
                Self::Ready,
                Self::PreprocessingDone,
                Self::Action,
                Self::Pong,
                Self::Info,
                Self::RenderCommands,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Identify => Some("Identify"),
                    Self::Ready => Some("Ready"),
                    Self::PreprocessingDone => Some("PreprocessingDone"),
                    Self::Action => Some("Action"),
                    Self::Pong => Some("Pong"),
                    Self::Info => Some("Info"),
                    Self::RenderCommands => Some("RenderCommands"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for BotMessage {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for BotMessage {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for BotMessage {
            type Output = BotMessage;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for BotMessage {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for BotMessage {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                u8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for BotMessage {}
        pub struct BotMessageUnionTableOffset {}

        // struct Vec2, aligned to 1
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Vec2(pub [u8; 2]);
        impl Default for Vec2 {
            fn default() -> Self {
                Self([0; 2])
            }
        }
        impl ::core::fmt::Debug for Vec2 {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                f.debug_struct("Vec2")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .finish()
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for Vec2 {}
        impl<'a> ::flatbuffers::Follow<'a> for Vec2 {
            type Inner = &'a Vec2;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { <&'a Vec2>::follow(buf, loc) }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for &'a Vec2 {
            type Inner = &'a Vec2;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                unsafe { ::flatbuffers::follow_cast_ref::<Vec2>(buf, loc) }
            }
        }
        impl<'b> ::flatbuffers::Push for Vec2 {
            type Output = Vec2;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = unsafe {
                    ::core::slice::from_raw_parts(
                        self as *const Vec2 as *const u8,
                        <Self as ::flatbuffers::Push>::size(),
                    )
                };
                dst.copy_from_slice(src);
            }
            #[inline]
            fn alignment() -> ::flatbuffers::PushAlignment {
                ::flatbuffers::PushAlignment::new(1)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for Vec2 {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Vec2 {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: u8, y: u8) -> Self {
                let mut s = Self([0; 2]);
                s.set_x(x);
                s.set_y(y);
                s
            }

            pub fn x(&self) -> u8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<u8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: u8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> u8 {
                let mut mem =
                    ::core::mem::MaybeUninit::<<u8 as ::flatbuffers::EndianScalar>::Scalar>::uninit(
                    );
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                ::flatbuffers::EndianScalar::from_little_endian(unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        self.0[1..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: u8) {
                let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    ::core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[1..].as_mut_ptr(),
                        ::core::mem::size_of::<<u8 as ::flatbuffers::EndianScalar>::Scalar>(),
                    );
                }
            }
        }

        pub enum WallOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Wall<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Wall<'a> {
            type Inner = Wall<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Wall<'a> {
            pub const VT_POS1: ::flatbuffers::VOffsetT = 4;
            pub const VT_POS2: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Wall { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args WallArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Wall<'bldr>> {
                let mut builder = WallBuilder::new(_fbb);
                if let Some(x) = args.pos2 {
                    builder.add_pos2(x);
                }
                if let Some(x) = args.pos1 {
                    builder.add_pos1(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn pos1(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(Wall::VT_POS1, None) }
            }
            #[inline]
            pub fn pos2(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(Wall::VT_POS2, None) }
            }
        }

        impl ::flatbuffers::Verifiable for Wall<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<Vec2>("pos1", Self::VT_POS1, false)?
                    .visit_field::<Vec2>("pos2", Self::VT_POS2, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct WallArgs<'a> {
            pub pos1: Option<&'a Vec2>,
            pub pos2: Option<&'a Vec2>,
        }
        impl<'a> Default for WallArgs<'a> {
            #[inline]
            fn default() -> Self {
                WallArgs {
                    pos1: None,
                    pos2: None,
                }
            }
        }

        pub struct WallBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> WallBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_pos1(&mut self, pos1: &Vec2) {
                self.fbb_.push_slot_always::<&Vec2>(Wall::VT_POS1, pos1);
            }
            #[inline]
            pub fn add_pos2(&mut self, pos2: &Vec2) {
                self.fbb_.push_slot_always::<&Vec2>(Wall::VT_POS2, pos2);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> WallBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                WallBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Wall<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Wall<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Wall");
                ds.field("pos1", &self.pos1());
                ds.field("pos2", &self.pos2());
                ds.finish()
            }
        }
        pub enum MudOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Mud<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Mud<'a> {
            type Inner = Mud<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Mud<'a> {
            pub const VT_POS1: ::flatbuffers::VOffsetT = 4;
            pub const VT_POS2: ::flatbuffers::VOffsetT = 6;
            pub const VT_VALUE: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Mud { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args MudArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Mud<'bldr>> {
                let mut builder = MudBuilder::new(_fbb);
                if let Some(x) = args.pos2 {
                    builder.add_pos2(x);
                }
                if let Some(x) = args.pos1 {
                    builder.add_pos1(x);
                }
                builder.add_value(args.value);
                builder.finish()
            }

            #[inline]
            pub fn pos1(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(Mud::VT_POS1, None) }
            }
            #[inline]
            pub fn pos2(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(Mud::VT_POS2, None) }
            }
            #[inline]
            pub fn value(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(Mud::VT_VALUE, Some(0)).unwrap() }
            }
        }

        impl ::flatbuffers::Verifiable for Mud<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<Vec2>("pos1", Self::VT_POS1, false)?
                    .visit_field::<Vec2>("pos2", Self::VT_POS2, false)?
                    .visit_field::<u8>("value", Self::VT_VALUE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct MudArgs<'a> {
            pub pos1: Option<&'a Vec2>,
            pub pos2: Option<&'a Vec2>,
            pub value: u8,
        }
        impl<'a> Default for MudArgs<'a> {
            #[inline]
            fn default() -> Self {
                MudArgs {
                    pos1: None,
                    pos2: None,
                    value: 0,
                }
            }
        }

        pub struct MudBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> MudBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_pos1(&mut self, pos1: &Vec2) {
                self.fbb_.push_slot_always::<&Vec2>(Mud::VT_POS1, pos1);
            }
            #[inline]
            pub fn add_pos2(&mut self, pos2: &Vec2) {
                self.fbb_.push_slot_always::<&Vec2>(Mud::VT_POS2, pos2);
            }
            #[inline]
            pub fn add_value(&mut self, value: u8) {
                self.fbb_.push_slot::<u8>(Mud::VT_VALUE, value, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> MudBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                MudBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Mud<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Mud<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Mud");
                ds.field("pos1", &self.pos1());
                ds.field("pos2", &self.pos2());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum OptionDefOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OptionDef<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for OptionDef<'a> {
            type Inner = OptionDef<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> OptionDef<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_TYPE_: ::flatbuffers::VOffsetT = 6;
            pub const VT_DEFAULT_VALUE: ::flatbuffers::VOffsetT = 8;
            pub const VT_MIN: ::flatbuffers::VOffsetT = 10;
            pub const VT_MAX: ::flatbuffers::VOffsetT = 12;
            pub const VT_CHOICES: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                OptionDef { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OptionDefArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<OptionDef<'bldr>> {
                let mut builder = OptionDefBuilder::new(_fbb);
                if let Some(x) = args.choices {
                    builder.add_choices(x);
                }
                builder.add_max(args.max);
                builder.add_min(args.min);
                if let Some(x) = args.default_value {
                    builder.add_default_value(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.add_type_(args.type_);
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(OptionDef::VT_NAME, None)
                }
            }
            #[inline]
            pub fn type_(&self) -> OptionType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<OptionType>(OptionDef::VT_TYPE_, Some(OptionType::Check))
                        .unwrap()
                }
            }
            #[inline]
            pub fn default_value(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        OptionDef::VT_DEFAULT_VALUE,
                        None,
                    )
                }
            }
            #[inline]
            pub fn min(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(OptionDef::VT_MIN, Some(0)).unwrap() }
            }
            #[inline]
            pub fn max(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(OptionDef::VT_MAX, Some(0)).unwrap() }
            }
            #[inline]
            pub fn choices(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(OptionDef::VT_CHOICES, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for OptionDef<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<OptionType>("type_", Self::VT_TYPE_, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "default_value",
                        Self::VT_DEFAULT_VALUE,
                        false,
                    )?
                    .visit_field::<i32>("min", Self::VT_MIN, false)?
                    .visit_field::<i32>("max", Self::VT_MAX, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("choices", Self::VT_CHOICES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct OptionDefArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub type_: OptionType,
            pub default_value: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub min: i32,
            pub max: i32,
            pub choices: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
        }
        impl<'a> Default for OptionDefArgs<'a> {
            #[inline]
            fn default() -> Self {
                OptionDefArgs {
                    name: None,
                    type_: OptionType::Check,
                    default_value: None,
                    min: 0,
                    max: 0,
                    choices: None,
                }
            }
        }

        pub struct OptionDefBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> OptionDefBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(OptionDef::VT_NAME, name);
            }
            #[inline]
            pub fn add_type_(&mut self, type_: OptionType) {
                self.fbb_
                    .push_slot::<OptionType>(OptionDef::VT_TYPE_, type_, OptionType::Check);
            }
            #[inline]
            pub fn add_default_value(&mut self, default_value: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    OptionDef::VT_DEFAULT_VALUE,
                    default_value,
                );
            }
            #[inline]
            pub fn add_min(&mut self, min: i32) {
                self.fbb_.push_slot::<i32>(OptionDef::VT_MIN, min, 0);
            }
            #[inline]
            pub fn add_max(&mut self, max: i32) {
                self.fbb_.push_slot::<i32>(OptionDef::VT_MAX, max, 0);
            }
            #[inline]
            pub fn add_choices(
                &mut self,
                choices: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    OptionDef::VT_CHOICES,
                    choices,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OptionDefBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OptionDefBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<OptionDef<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for OptionDef<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("OptionDef");
                ds.field("name", &self.name());
                ds.field("type_", &self.type_());
                ds.field("default_value", &self.default_value());
                ds.field("min", &self.min());
                ds.field("max", &self.max());
                ds.field("choices", &self.choices());
                ds.finish()
            }
        }
        pub enum SetOptionOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SetOption<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for SetOption<'a> {
            type Inner = SetOption<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SetOption<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                SetOption { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SetOptionArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<SetOption<'bldr>> {
                let mut builder = SetOptionBuilder::new(_fbb);
                if let Some(x) = args.value {
                    builder.add_value(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(SetOption::VT_NAME, None)
                }
            }
            #[inline]
            pub fn value(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(SetOption::VT_VALUE, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for SetOption<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "value",
                        Self::VT_VALUE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct SetOptionArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub value: Option<::flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for SetOptionArgs<'a> {
            #[inline]
            fn default() -> Self {
                SetOptionArgs {
                    name: None,
                    value: None,
                }
            }
        }

        pub struct SetOptionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SetOptionBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(SetOption::VT_NAME, name);
            }
            #[inline]
            pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(SetOption::VT_VALUE, value);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SetOptionBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SetOptionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<SetOption<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for SetOption<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("SetOption");
                ds.field("name", &self.name());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum MatchConfigOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MatchConfig<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for MatchConfig<'a> {
            type Inner = MatchConfig<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> MatchConfig<'a> {
            pub const VT_WIDTH: ::flatbuffers::VOffsetT = 4;
            pub const VT_HEIGHT: ::flatbuffers::VOffsetT = 6;
            pub const VT_MAX_TURNS: ::flatbuffers::VOffsetT = 8;
            pub const VT_WALLS: ::flatbuffers::VOffsetT = 10;
            pub const VT_MUD: ::flatbuffers::VOffsetT = 12;
            pub const VT_CHEESE: ::flatbuffers::VOffsetT = 14;
            pub const VT_RAT_START: ::flatbuffers::VOffsetT = 16;
            pub const VT_PYTHON_START: ::flatbuffers::VOffsetT = 18;
            pub const VT_YOU_ARE: ::flatbuffers::VOffsetT = 20;
            pub const VT_TIMING: ::flatbuffers::VOffsetT = 22;
            pub const VT_MOVE_TIMEOUT_MS: ::flatbuffers::VOffsetT = 24;
            pub const VT_PREPROCESSING_TIMEOUT_MS: ::flatbuffers::VOffsetT = 26;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                MatchConfig { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args MatchConfigArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<MatchConfig<'bldr>> {
                let mut builder = MatchConfigBuilder::new(_fbb);
                builder.add_preprocessing_timeout_ms(args.preprocessing_timeout_ms);
                builder.add_move_timeout_ms(args.move_timeout_ms);
                if let Some(x) = args.python_start {
                    builder.add_python_start(x);
                }
                if let Some(x) = args.rat_start {
                    builder.add_rat_start(x);
                }
                if let Some(x) = args.cheese {
                    builder.add_cheese(x);
                }
                if let Some(x) = args.mud {
                    builder.add_mud(x);
                }
                if let Some(x) = args.walls {
                    builder.add_walls(x);
                }
                builder.add_max_turns(args.max_turns);
                builder.add_timing(args.timing);
                builder.add_you_are(args.you_are);
                builder.add_height(args.height);
                builder.add_width(args.width);
                builder.finish()
            }

            #[inline]
            pub fn width(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(MatchConfig::VT_WIDTH, Some(0)).unwrap() }
            }
            #[inline]
            pub fn height(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(MatchConfig::VT_HEIGHT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn max_turns(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(MatchConfig::VT_MAX_TURNS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn walls(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Wall<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Wall>>,
                    >>(MatchConfig::VT_WALLS, None)
                }
            }
            #[inline]
            pub fn mud(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Mud<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Mud>>,
                    >>(MatchConfig::VT_MUD, None)
                }
            }
            #[inline]
            pub fn cheese(&self) -> Option<::flatbuffers::Vector<'a, Vec2>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Vec2>>>(
                            MatchConfig::VT_CHEESE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn rat_start(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(MatchConfig::VT_RAT_START, None) }
            }
            #[inline]
            pub fn python_start(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(MatchConfig::VT_PYTHON_START, None) }
            }
            #[inline]
            pub fn you_are(&self) -> Player {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Player>(MatchConfig::VT_YOU_ARE, Some(Player::Rat))
                        .unwrap()
                }
            }
            #[inline]
            pub fn timing(&self) -> TimingMode {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TimingMode>(MatchConfig::VT_TIMING, Some(TimingMode::Wait))
                        .unwrap()
                }
            }
            #[inline]
            pub fn move_timeout_ms(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(MatchConfig::VT_MOVE_TIMEOUT_MS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn preprocessing_timeout_ms(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(MatchConfig::VT_PREPROCESSING_TIMEOUT_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for MatchConfig<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u8>("width", Self::VT_WIDTH, false)?
                    .visit_field::<u8>("height", Self::VT_HEIGHT, false)?
                    .visit_field::<u16>("max_turns", Self::VT_MAX_TURNS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Wall>>,
                    >>("walls", Self::VT_WALLS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Mud>>,
                    >>("mud", Self::VT_MUD, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Vec2>>>(
                        "cheese",
                        Self::VT_CHEESE,
                        false,
                    )?
                    .visit_field::<Vec2>("rat_start", Self::VT_RAT_START, false)?
                    .visit_field::<Vec2>("python_start", Self::VT_PYTHON_START, false)?
                    .visit_field::<Player>("you_are", Self::VT_YOU_ARE, false)?
                    .visit_field::<TimingMode>("timing", Self::VT_TIMING, false)?
                    .visit_field::<u32>("move_timeout_ms", Self::VT_MOVE_TIMEOUT_MS, false)?
                    .visit_field::<u32>(
                        "preprocessing_timeout_ms",
                        Self::VT_PREPROCESSING_TIMEOUT_MS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MatchConfigArgs<'a> {
            pub width: u8,
            pub height: u8,
            pub max_turns: u16,
            pub walls: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Wall<'a>>>,
                >,
            >,
            pub mud: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Mud<'a>>>,
                >,
            >,
            pub cheese: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Vec2>>>,
            pub rat_start: Option<&'a Vec2>,
            pub python_start: Option<&'a Vec2>,
            pub you_are: Player,
            pub timing: TimingMode,
            pub move_timeout_ms: u32,
            pub preprocessing_timeout_ms: u32,
        }
        impl<'a> Default for MatchConfigArgs<'a> {
            #[inline]
            fn default() -> Self {
                MatchConfigArgs {
                    width: 0,
                    height: 0,
                    max_turns: 0,
                    walls: None,
                    mud: None,
                    cheese: None,
                    rat_start: None,
                    python_start: None,
                    you_are: Player::Rat,
                    timing: TimingMode::Wait,
                    move_timeout_ms: 0,
                    preprocessing_timeout_ms: 0,
                }
            }
        }

        pub struct MatchConfigBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> MatchConfigBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_width(&mut self, width: u8) {
                self.fbb_.push_slot::<u8>(MatchConfig::VT_WIDTH, width, 0);
            }
            #[inline]
            pub fn add_height(&mut self, height: u8) {
                self.fbb_.push_slot::<u8>(MatchConfig::VT_HEIGHT, height, 0);
            }
            #[inline]
            pub fn add_max_turns(&mut self, max_turns: u16) {
                self.fbb_
                    .push_slot::<u16>(MatchConfig::VT_MAX_TURNS, max_turns, 0);
            }
            #[inline]
            pub fn add_walls(
                &mut self,
                walls: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Wall<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(MatchConfig::VT_WALLS, walls);
            }
            #[inline]
            pub fn add_mud(
                &mut self,
                mud: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Mud<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(MatchConfig::VT_MUD, mud);
            }
            #[inline]
            pub fn add_cheese(
                &mut self,
                cheese: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, Vec2>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    MatchConfig::VT_CHEESE,
                    cheese,
                );
            }
            #[inline]
            pub fn add_rat_start(&mut self, rat_start: &Vec2) {
                self.fbb_
                    .push_slot_always::<&Vec2>(MatchConfig::VT_RAT_START, rat_start);
            }
            #[inline]
            pub fn add_python_start(&mut self, python_start: &Vec2) {
                self.fbb_
                    .push_slot_always::<&Vec2>(MatchConfig::VT_PYTHON_START, python_start);
            }
            #[inline]
            pub fn add_you_are(&mut self, you_are: Player) {
                self.fbb_
                    .push_slot::<Player>(MatchConfig::VT_YOU_ARE, you_are, Player::Rat);
            }
            #[inline]
            pub fn add_timing(&mut self, timing: TimingMode) {
                self.fbb_
                    .push_slot::<TimingMode>(MatchConfig::VT_TIMING, timing, TimingMode::Wait);
            }
            #[inline]
            pub fn add_move_timeout_ms(&mut self, move_timeout_ms: u32) {
                self.fbb_
                    .push_slot::<u32>(MatchConfig::VT_MOVE_TIMEOUT_MS, move_timeout_ms, 0);
            }
            #[inline]
            pub fn add_preprocessing_timeout_ms(&mut self, preprocessing_timeout_ms: u32) {
                self.fbb_.push_slot::<u32>(
                    MatchConfig::VT_PREPROCESSING_TIMEOUT_MS,
                    preprocessing_timeout_ms,
                    0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> MatchConfigBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                MatchConfigBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<MatchConfig<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for MatchConfig<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("MatchConfig");
                ds.field("width", &self.width());
                ds.field("height", &self.height());
                ds.field("max_turns", &self.max_turns());
                ds.field("walls", &self.walls());
                ds.field("mud", &self.mud());
                ds.field("cheese", &self.cheese());
                ds.field("rat_start", &self.rat_start());
                ds.field("python_start", &self.python_start());
                ds.field("you_are", &self.you_are());
                ds.field("timing", &self.timing());
                ds.field("move_timeout_ms", &self.move_timeout_ms());
                ds.field("preprocessing_timeout_ms", &self.preprocessing_timeout_ms());
                ds.finish()
            }
        }
        pub enum StartPreprocessingOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StartPreprocessing<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for StartPreprocessing<'a> {
            type Inner = StartPreprocessing<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> StartPreprocessing<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                StartPreprocessing { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args StartPreprocessingArgs,
            ) -> ::flatbuffers::WIPOffset<StartPreprocessing<'bldr>> {
                let mut builder = StartPreprocessingBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for StartPreprocessing<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct StartPreprocessingArgs {}
        impl<'a> Default for StartPreprocessingArgs {
            #[inline]
            fn default() -> Self {
                StartPreprocessingArgs {}
            }
        }

        pub struct StartPreprocessingBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StartPreprocessingBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StartPreprocessingBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StartPreprocessingBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<StartPreprocessing<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for StartPreprocessing<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("StartPreprocessing");
                ds.finish()
            }
        }
        pub enum TurnStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TurnState<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for TurnState<'a> {
            type Inner = TurnState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TurnState<'a> {
            pub const VT_TURN: ::flatbuffers::VOffsetT = 4;
            pub const VT_RAT_POSITION: ::flatbuffers::VOffsetT = 6;
            pub const VT_PYTHON_POSITION: ::flatbuffers::VOffsetT = 8;
            pub const VT_RAT_SCORE: ::flatbuffers::VOffsetT = 10;
            pub const VT_PYTHON_SCORE: ::flatbuffers::VOffsetT = 12;
            pub const VT_RAT_MUD_TURNS: ::flatbuffers::VOffsetT = 14;
            pub const VT_PYTHON_MUD_TURNS: ::flatbuffers::VOffsetT = 16;
            pub const VT_CHEESE: ::flatbuffers::VOffsetT = 18;
            pub const VT_RAT_LAST_MOVE: ::flatbuffers::VOffsetT = 20;
            pub const VT_PYTHON_LAST_MOVE: ::flatbuffers::VOffsetT = 22;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                TurnState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TurnStateArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<TurnState<'bldr>> {
                let mut builder = TurnStateBuilder::new(_fbb);
                if let Some(x) = args.cheese {
                    builder.add_cheese(x);
                }
                builder.add_python_score(args.python_score);
                builder.add_rat_score(args.rat_score);
                if let Some(x) = args.python_position {
                    builder.add_python_position(x);
                }
                if let Some(x) = args.rat_position {
                    builder.add_rat_position(x);
                }
                builder.add_turn(args.turn);
                builder.add_python_last_move(args.python_last_move);
                builder.add_rat_last_move(args.rat_last_move);
                builder.add_python_mud_turns(args.python_mud_turns);
                builder.add_rat_mud_turns(args.rat_mud_turns);
                builder.finish()
            }

            #[inline]
            pub fn turn(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u16>(TurnState::VT_TURN, Some(0)).unwrap() }
            }
            #[inline]
            pub fn rat_position(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(TurnState::VT_RAT_POSITION, None) }
            }
            #[inline]
            pub fn python_position(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(TurnState::VT_PYTHON_POSITION, None) }
            }
            #[inline]
            pub fn rat_score(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(TurnState::VT_RAT_SCORE, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn python_score(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(TurnState::VT_PYTHON_SCORE, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn rat_mud_turns(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(TurnState::VT_RAT_MUD_TURNS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn python_mud_turns(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(TurnState::VT_PYTHON_MUD_TURNS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn cheese(&self) -> Option<::flatbuffers::Vector<'a, Vec2>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Vec2>>>(
                            TurnState::VT_CHEESE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn rat_last_move(&self) -> Direction {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Direction>(TurnState::VT_RAT_LAST_MOVE, Some(Direction::Up))
                        .unwrap()
                }
            }
            #[inline]
            pub fn python_last_move(&self) -> Direction {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Direction>(TurnState::VT_PYTHON_LAST_MOVE, Some(Direction::Up))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for TurnState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<u16>("turn", Self::VT_TURN, false)?
                    .visit_field::<Vec2>("rat_position", Self::VT_RAT_POSITION, false)?
                    .visit_field::<Vec2>("python_position", Self::VT_PYTHON_POSITION, false)?
                    .visit_field::<f32>("rat_score", Self::VT_RAT_SCORE, false)?
                    .visit_field::<f32>("python_score", Self::VT_PYTHON_SCORE, false)?
                    .visit_field::<u8>("rat_mud_turns", Self::VT_RAT_MUD_TURNS, false)?
                    .visit_field::<u8>("python_mud_turns", Self::VT_PYTHON_MUD_TURNS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Vec2>>>(
                        "cheese",
                        Self::VT_CHEESE,
                        false,
                    )?
                    .visit_field::<Direction>("rat_last_move", Self::VT_RAT_LAST_MOVE, false)?
                    .visit_field::<Direction>("python_last_move", Self::VT_PYTHON_LAST_MOVE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TurnStateArgs<'a> {
            pub turn: u16,
            pub rat_position: Option<&'a Vec2>,
            pub python_position: Option<&'a Vec2>,
            pub rat_score: f32,
            pub python_score: f32,
            pub rat_mud_turns: u8,
            pub python_mud_turns: u8,
            pub cheese: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Vec2>>>,
            pub rat_last_move: Direction,
            pub python_last_move: Direction,
        }
        impl<'a> Default for TurnStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                TurnStateArgs {
                    turn: 0,
                    rat_position: None,
                    python_position: None,
                    rat_score: 0.0,
                    python_score: 0.0,
                    rat_mud_turns: 0,
                    python_mud_turns: 0,
                    cheese: None,
                    rat_last_move: Direction::Up,
                    python_last_move: Direction::Up,
                }
            }
        }

        pub struct TurnStateBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TurnStateBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_turn(&mut self, turn: u16) {
                self.fbb_.push_slot::<u16>(TurnState::VT_TURN, turn, 0);
            }
            #[inline]
            pub fn add_rat_position(&mut self, rat_position: &Vec2) {
                self.fbb_
                    .push_slot_always::<&Vec2>(TurnState::VT_RAT_POSITION, rat_position);
            }
            #[inline]
            pub fn add_python_position(&mut self, python_position: &Vec2) {
                self.fbb_
                    .push_slot_always::<&Vec2>(TurnState::VT_PYTHON_POSITION, python_position);
            }
            #[inline]
            pub fn add_rat_score(&mut self, rat_score: f32) {
                self.fbb_
                    .push_slot::<f32>(TurnState::VT_RAT_SCORE, rat_score, 0.0);
            }
            #[inline]
            pub fn add_python_score(&mut self, python_score: f32) {
                self.fbb_
                    .push_slot::<f32>(TurnState::VT_PYTHON_SCORE, python_score, 0.0);
            }
            #[inline]
            pub fn add_rat_mud_turns(&mut self, rat_mud_turns: u8) {
                self.fbb_
                    .push_slot::<u8>(TurnState::VT_RAT_MUD_TURNS, rat_mud_turns, 0);
            }
            #[inline]
            pub fn add_python_mud_turns(&mut self, python_mud_turns: u8) {
                self.fbb_
                    .push_slot::<u8>(TurnState::VT_PYTHON_MUD_TURNS, python_mud_turns, 0);
            }
            #[inline]
            pub fn add_cheese(
                &mut self,
                cheese: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, Vec2>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(TurnState::VT_CHEESE, cheese);
            }
            #[inline]
            pub fn add_rat_last_move(&mut self, rat_last_move: Direction) {
                self.fbb_.push_slot::<Direction>(
                    TurnState::VT_RAT_LAST_MOVE,
                    rat_last_move,
                    Direction::Up,
                );
            }
            #[inline]
            pub fn add_python_last_move(&mut self, python_last_move: Direction) {
                self.fbb_.push_slot::<Direction>(
                    TurnState::VT_PYTHON_LAST_MOVE,
                    python_last_move,
                    Direction::Up,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TurnStateBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TurnStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<TurnState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for TurnState<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("TurnState");
                ds.field("turn", &self.turn());
                ds.field("rat_position", &self.rat_position());
                ds.field("python_position", &self.python_position());
                ds.field("rat_score", &self.rat_score());
                ds.field("python_score", &self.python_score());
                ds.field("rat_mud_turns", &self.rat_mud_turns());
                ds.field("python_mud_turns", &self.python_mud_turns());
                ds.field("cheese", &self.cheese());
                ds.field("rat_last_move", &self.rat_last_move());
                ds.field("python_last_move", &self.python_last_move());
                ds.finish()
            }
        }
        pub enum StopOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Stop<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Stop<'a> {
            type Inner = Stop<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Stop<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Stop { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args StopArgs,
            ) -> ::flatbuffers::WIPOffset<Stop<'bldr>> {
                let mut builder = StopBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for Stop<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct StopArgs {}
        impl<'a> Default for StopArgs {
            #[inline]
            fn default() -> Self {
                StopArgs {}
            }
        }

        pub struct StopBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StopBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StopBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StopBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Stop<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Stop<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Stop");
                ds.finish()
            }
        }
        pub enum TimeoutOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Timeout<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Timeout<'a> {
            type Inner = Timeout<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Timeout<'a> {
            pub const VT_DEFAULT_MOVE: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Timeout { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TimeoutArgs,
            ) -> ::flatbuffers::WIPOffset<Timeout<'bldr>> {
                let mut builder = TimeoutBuilder::new(_fbb);
                builder.add_default_move(args.default_move);
                builder.finish()
            }

            #[inline]
            pub fn default_move(&self) -> Direction {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Direction>(Timeout::VT_DEFAULT_MOVE, Some(Direction::Up))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for Timeout<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<Direction>("default_move", Self::VT_DEFAULT_MOVE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TimeoutArgs {
            pub default_move: Direction,
        }
        impl<'a> Default for TimeoutArgs {
            #[inline]
            fn default() -> Self {
                TimeoutArgs {
                    default_move: Direction::Up,
                }
            }
        }

        pub struct TimeoutBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TimeoutBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_default_move(&mut self, default_move: Direction) {
                self.fbb_.push_slot::<Direction>(
                    Timeout::VT_DEFAULT_MOVE,
                    default_move,
                    Direction::Up,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TimeoutBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TimeoutBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Timeout<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Timeout<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Timeout");
                ds.field("default_move", &self.default_move());
                ds.finish()
            }
        }
        pub enum GameOverOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GameOver<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for GameOver<'a> {
            type Inner = GameOver<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> GameOver<'a> {
            pub const VT_RESULT: ::flatbuffers::VOffsetT = 4;
            pub const VT_RAT_SCORE: ::flatbuffers::VOffsetT = 6;
            pub const VT_PYTHON_SCORE: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                GameOver { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args GameOverArgs,
            ) -> ::flatbuffers::WIPOffset<GameOver<'bldr>> {
                let mut builder = GameOverBuilder::new(_fbb);
                builder.add_python_score(args.python_score);
                builder.add_rat_score(args.rat_score);
                builder.add_result(args.result);
                builder.finish()
            }

            #[inline]
            pub fn result(&self) -> GameResult {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<GameResult>(GameOver::VT_RESULT, Some(GameResult::Rat))
                        .unwrap()
                }
            }
            #[inline]
            pub fn rat_score(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GameOver::VT_RAT_SCORE, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn python_score(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GameOver::VT_PYTHON_SCORE, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for GameOver<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<GameResult>("result", Self::VT_RESULT, false)?
                    .visit_field::<f32>("rat_score", Self::VT_RAT_SCORE, false)?
                    .visit_field::<f32>("python_score", Self::VT_PYTHON_SCORE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct GameOverArgs {
            pub result: GameResult,
            pub rat_score: f32,
            pub python_score: f32,
        }
        impl<'a> Default for GameOverArgs {
            #[inline]
            fn default() -> Self {
                GameOverArgs {
                    result: GameResult::Rat,
                    rat_score: 0.0,
                    python_score: 0.0,
                }
            }
        }

        pub struct GameOverBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GameOverBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_result(&mut self, result: GameResult) {
                self.fbb_
                    .push_slot::<GameResult>(GameOver::VT_RESULT, result, GameResult::Rat);
            }
            #[inline]
            pub fn add_rat_score(&mut self, rat_score: f32) {
                self.fbb_
                    .push_slot::<f32>(GameOver::VT_RAT_SCORE, rat_score, 0.0);
            }
            #[inline]
            pub fn add_python_score(&mut self, python_score: f32) {
                self.fbb_
                    .push_slot::<f32>(GameOver::VT_PYTHON_SCORE, python_score, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> GameOverBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                GameOverBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<GameOver<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for GameOver<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("GameOver");
                ds.field("result", &self.result());
                ds.field("rat_score", &self.rat_score());
                ds.field("python_score", &self.python_score());
                ds.finish()
            }
        }
        pub enum PingOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Ping<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Ping<'a> {
            type Inner = Ping<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Ping<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Ping { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args PingArgs,
            ) -> ::flatbuffers::WIPOffset<Ping<'bldr>> {
                let mut builder = PingBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for Ping<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct PingArgs {}
        impl<'a> Default for PingArgs {
            #[inline]
            fn default() -> Self {
                PingArgs {}
            }
        }

        pub struct PingBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> PingBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PingBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PingBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Ping<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Ping<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Ping");
                ds.finish()
            }
        }
        pub enum HostPacketOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct HostPacket<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for HostPacket<'a> {
            type Inner = HostPacket<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> HostPacket<'a> {
            pub const VT_MESSAGE_TYPE: ::flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                HostPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args HostPacketArgs,
            ) -> ::flatbuffers::WIPOffset<HostPacket<'bldr>> {
                let mut builder = HostPacketBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_message_type(args.message_type);
                builder.finish()
            }

            #[inline]
            pub fn message_type(&self) -> HostMessage {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<HostMessage>(HostPacket::VT_MESSAGE_TYPE, Some(HostMessage::NONE))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<::flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(
                            HostPacket::VT_MESSAGE,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_set_option(&self) -> Option<SetOption<'a>> {
                if self.message_type() == HostMessage::SetOption {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SetOption::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_match_config(&self) -> Option<MatchConfig<'a>> {
                if self.message_type() == HostMessage::MatchConfig {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { MatchConfig::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_start_preprocessing(&self) -> Option<StartPreprocessing<'a>> {
                if self.message_type() == HostMessage::StartPreprocessing {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StartPreprocessing::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_turn_state(&self) -> Option<TurnState<'a>> {
                if self.message_type() == HostMessage::TurnState {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { TurnState::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_stop(&self) -> Option<Stop<'a>> {
                if self.message_type() == HostMessage::Stop {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Stop::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_timeout(&self) -> Option<Timeout<'a>> {
                if self.message_type() == HostMessage::Timeout {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Timeout::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_game_over(&self) -> Option<GameOver<'a>> {
                if self.message_type() == HostMessage::GameOver {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { GameOver::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_ping(&self) -> Option<Ping<'a>> {
                if self.message_type() == HostMessage::Ping {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Ping::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl ::flatbuffers::Verifiable for HostPacket<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_union::<HostMessage, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          HostMessage::SetOption => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<SetOption>>("HostMessage::SetOption", pos),
          HostMessage::MatchConfig => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<MatchConfig>>("HostMessage::MatchConfig", pos),
          HostMessage::StartPreprocessing => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<StartPreprocessing>>("HostMessage::StartPreprocessing", pos),
          HostMessage::TurnState => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<TurnState>>("HostMessage::TurnState", pos),
          HostMessage::Stop => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Stop>>("HostMessage::Stop", pos),
          HostMessage::Timeout => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Timeout>>("HostMessage::Timeout", pos),
          HostMessage::GameOver => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<GameOver>>("HostMessage::GameOver", pos),
          HostMessage::Ping => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Ping>>("HostMessage::Ping", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct HostPacketArgs {
            pub message_type: HostMessage,
            pub message: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for HostPacketArgs {
            #[inline]
            fn default() -> Self {
                HostPacketArgs {
                    message_type: HostMessage::NONE,
                    message: None,
                }
            }
        }

        pub struct HostPacketBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> HostPacketBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message_type(&mut self, message_type: HostMessage) {
                self.fbb_.push_slot::<HostMessage>(
                    HostPacket::VT_MESSAGE_TYPE,
                    message_type,
                    HostMessage::NONE,
                );
            }
            #[inline]
            pub fn add_message(
                &mut self,
                message: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    HostPacket::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> HostPacketBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                HostPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<HostPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for HostPacket<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("HostPacket");
                ds.field("message_type", &self.message_type());
                match self.message_type() {
                    HostMessage::SetOption => {
                        if let Some(x) = self.message_as_set_option() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::MatchConfig => {
                        if let Some(x) = self.message_as_match_config() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::StartPreprocessing => {
                        if let Some(x) = self.message_as_start_preprocessing() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::TurnState => {
                        if let Some(x) = self.message_as_turn_state() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::Stop => {
                        if let Some(x) = self.message_as_stop() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::Timeout => {
                        if let Some(x) = self.message_as_timeout() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::GameOver => {
                        if let Some(x) = self.message_as_game_over() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    HostMessage::Ping => {
                        if let Some(x) = self.message_as_ping() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    _ => {
                        let x: Option<()> = None;
                        ds.field("message", &x)
                    },
                };
                ds.finish()
            }
        }
        pub enum IdentifyOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Identify<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Identify<'a> {
            type Inner = Identify<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Identify<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_AUTHOR: ::flatbuffers::VOffsetT = 6;
            pub const VT_OPTIONS: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Identify { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args IdentifyArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Identify<'bldr>> {
                let mut builder = IdentifyBuilder::new(_fbb);
                if let Some(x) = args.options {
                    builder.add_options(x);
                }
                if let Some(x) = args.author {
                    builder.add_author(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Identify::VT_NAME, None)
                }
            }
            #[inline]
            pub fn author(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Identify::VT_AUTHOR, None)
                }
            }
            #[inline]
            pub fn options(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<OptionDef<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<OptionDef>>,
                    >>(Identify::VT_OPTIONS, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for Identify<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "author",
                        Self::VT_AUTHOR,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<OptionDef>>,
                    >>("options", Self::VT_OPTIONS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct IdentifyArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub author: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub options: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<OptionDef<'a>>>,
                >,
            >,
        }
        impl<'a> Default for IdentifyArgs<'a> {
            #[inline]
            fn default() -> Self {
                IdentifyArgs {
                    name: None,
                    author: None,
                    options: None,
                }
            }
        }

        pub struct IdentifyBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> IdentifyBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Identify::VT_NAME, name);
            }
            #[inline]
            pub fn add_author(&mut self, author: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Identify::VT_AUTHOR, author);
            }
            #[inline]
            pub fn add_options(
                &mut self,
                options: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<OptionDef<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Identify::VT_OPTIONS, options);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> IdentifyBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                IdentifyBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Identify<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Identify<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Identify");
                ds.field("name", &self.name());
                ds.field("author", &self.author());
                ds.field("options", &self.options());
                ds.finish()
            }
        }
        pub enum ReadyOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Ready<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Ready<'a> {
            type Inner = Ready<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Ready<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Ready { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args ReadyArgs,
            ) -> ::flatbuffers::WIPOffset<Ready<'bldr>> {
                let mut builder = ReadyBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for Ready<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct ReadyArgs {}
        impl<'a> Default for ReadyArgs {
            #[inline]
            fn default() -> Self {
                ReadyArgs {}
            }
        }

        pub struct ReadyBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ReadyBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ReadyBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ReadyBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Ready<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Ready<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Ready");
                ds.finish()
            }
        }
        pub enum PreprocessingDoneOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PreprocessingDone<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for PreprocessingDone<'a> {
            type Inner = PreprocessingDone<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> PreprocessingDone<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                PreprocessingDone { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args PreprocessingDoneArgs,
            ) -> ::flatbuffers::WIPOffset<PreprocessingDone<'bldr>> {
                let mut builder = PreprocessingDoneBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for PreprocessingDone<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct PreprocessingDoneArgs {}
        impl<'a> Default for PreprocessingDoneArgs {
            #[inline]
            fn default() -> Self {
                PreprocessingDoneArgs {}
            }
        }

        pub struct PreprocessingDoneBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> PreprocessingDoneBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PreprocessingDoneBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PreprocessingDoneBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<PreprocessingDone<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for PreprocessingDone<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("PreprocessingDone");
                ds.finish()
            }
        }
        pub enum ActionOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Action<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Action<'a> {
            type Inner = Action<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Action<'a> {
            pub const VT_DIRECTION: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Action { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ActionArgs,
            ) -> ::flatbuffers::WIPOffset<Action<'bldr>> {
                let mut builder = ActionBuilder::new(_fbb);
                builder.add_direction(args.direction);
                builder.finish()
            }

            #[inline]
            pub fn direction(&self) -> Direction {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Direction>(Action::VT_DIRECTION, Some(Direction::Up))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for Action<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<Direction>("direction", Self::VT_DIRECTION, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ActionArgs {
            pub direction: Direction,
        }
        impl<'a> Default for ActionArgs {
            #[inline]
            fn default() -> Self {
                ActionArgs {
                    direction: Direction::Up,
                }
            }
        }

        pub struct ActionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ActionBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_direction(&mut self, direction: Direction) {
                self.fbb_
                    .push_slot::<Direction>(Action::VT_DIRECTION, direction, Direction::Up);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ActionBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ActionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Action<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Action<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Action");
                ds.field("direction", &self.direction());
                ds.finish()
            }
        }
        pub enum PongOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Pong<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Pong<'a> {
            type Inner = Pong<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Pong<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Pong { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args PongArgs,
            ) -> ::flatbuffers::WIPOffset<Pong<'bldr>> {
                let mut builder = PongBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for Pong<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct PongArgs {}
        impl<'a> Default for PongArgs {
            #[inline]
            fn default() -> Self {
                PongArgs {}
            }
        }

        pub struct PongBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> PongBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PongBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PongBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Pong<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Pong<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Pong");
                ds.finish()
            }
        }
        pub enum InfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Info<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Info<'a> {
            type Inner = Info<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Info<'a> {
            pub const VT_TARGET: ::flatbuffers::VOffsetT = 4;
            pub const VT_DEPTH: ::flatbuffers::VOffsetT = 6;
            pub const VT_NODES: ::flatbuffers::VOffsetT = 8;
            pub const VT_SCORE: ::flatbuffers::VOffsetT = 10;
            pub const VT_PATH: ::flatbuffers::VOffsetT = 12;
            pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Info { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args InfoArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Info<'bldr>> {
                let mut builder = InfoBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                if let Some(x) = args.path {
                    builder.add_path(x);
                }
                builder.add_score(args.score);
                builder.add_nodes(args.nodes);
                if let Some(x) = args.target {
                    builder.add_target(x);
                }
                builder.add_depth(args.depth);
                builder.finish()
            }

            #[inline]
            pub fn target(&self) -> Option<&'a Vec2> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vec2>(Info::VT_TARGET, None) }
            }
            #[inline]
            pub fn depth(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u16>(Info::VT_DEPTH, Some(0)).unwrap() }
            }
            #[inline]
            pub fn nodes(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(Info::VT_NODES, Some(0)).unwrap() }
            }
            #[inline]
            pub fn score(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<f32>(Info::VT_SCORE, Some(0.0)).unwrap() }
            }
            #[inline]
            pub fn path(&self) -> Option<::flatbuffers::Vector<'a, Vec2>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Vec2>>>(
                            Info::VT_PATH,
                            None,
                        )
                }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Info::VT_MESSAGE, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for Info<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<Vec2>("target", Self::VT_TARGET, false)?
                    .visit_field::<u16>("depth", Self::VT_DEPTH, false)?
                    .visit_field::<u32>("nodes", Self::VT_NODES, false)?
                    .visit_field::<f32>("score", Self::VT_SCORE, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Vec2>>>(
                        "path",
                        Self::VT_PATH,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct InfoArgs<'a> {
            pub target: Option<&'a Vec2>,
            pub depth: u16,
            pub nodes: u32,
            pub score: f32,
            pub path: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Vec2>>>,
            pub message: Option<::flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for InfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                InfoArgs {
                    target: None,
                    depth: 0,
                    nodes: 0,
                    score: 0.0,
                    path: None,
                    message: None,
                }
            }
        }

        pub struct InfoBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> InfoBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_target(&mut self, target: &Vec2) {
                self.fbb_.push_slot_always::<&Vec2>(Info::VT_TARGET, target);
            }
            #[inline]
            pub fn add_depth(&mut self, depth: u16) {
                self.fbb_.push_slot::<u16>(Info::VT_DEPTH, depth, 0);
            }
            #[inline]
            pub fn add_nodes(&mut self, nodes: u32) {
                self.fbb_.push_slot::<u32>(Info::VT_NODES, nodes, 0);
            }
            #[inline]
            pub fn add_score(&mut self, score: f32) {
                self.fbb_.push_slot::<f32>(Info::VT_SCORE, score, 0.0);
            }
            #[inline]
            pub fn add_path(
                &mut self,
                path: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, Vec2>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Info::VT_PATH, path);
            }
            #[inline]
            pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Info::VT_MESSAGE, message);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> InfoBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                InfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Info<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Info<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Info");
                ds.field("target", &self.target());
                ds.field("depth", &self.depth());
                ds.field("nodes", &self.nodes());
                ds.field("score", &self.score());
                ds.field("path", &self.path());
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum RenderCommandsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct RenderCommands<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for RenderCommands<'a> {
            type Inner = RenderCommands<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> RenderCommands<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                RenderCommands { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args RenderCommandsArgs,
            ) -> ::flatbuffers::WIPOffset<RenderCommands<'bldr>> {
                let mut builder = RenderCommandsBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl ::flatbuffers::Verifiable for RenderCommands<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct RenderCommandsArgs {}
        impl<'a> Default for RenderCommandsArgs {
            #[inline]
            fn default() -> Self {
                RenderCommandsArgs {}
            }
        }

        pub struct RenderCommandsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RenderCommandsBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> RenderCommandsBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                RenderCommandsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<RenderCommands<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for RenderCommands<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("RenderCommands");
                ds.finish()
            }
        }
        pub enum BotPacketOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BotPacket<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for BotPacket<'a> {
            type Inner = BotPacket<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> BotPacket<'a> {
            pub const VT_MESSAGE_TYPE: ::flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                BotPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args BotPacketArgs,
            ) -> ::flatbuffers::WIPOffset<BotPacket<'bldr>> {
                let mut builder = BotPacketBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_message_type(args.message_type);
                builder.finish()
            }

            #[inline]
            pub fn message_type(&self) -> BotMessage {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BotMessage>(BotPacket::VT_MESSAGE_TYPE, Some(BotMessage::NONE))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<::flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(
                            BotPacket::VT_MESSAGE,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_identify(&self) -> Option<Identify<'a>> {
                if self.message_type() == BotMessage::Identify {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Identify::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_ready(&self) -> Option<Ready<'a>> {
                if self.message_type() == BotMessage::Ready {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Ready::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_preprocessing_done(&self) -> Option<PreprocessingDone<'a>> {
                if self.message_type() == BotMessage::PreprocessingDone {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { PreprocessingDone::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_action(&self) -> Option<Action<'a>> {
                if self.message_type() == BotMessage::Action {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Action::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_pong(&self) -> Option<Pong<'a>> {
                if self.message_type() == BotMessage::Pong {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Pong::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_info(&self) -> Option<Info<'a>> {
                if self.message_type() == BotMessage::Info {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { Info::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn message_as_render_commands(&self) -> Option<RenderCommands<'a>> {
                if self.message_type() == BotMessage::RenderCommands {
                    self.message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { RenderCommands::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl ::flatbuffers::Verifiable for BotPacket<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
     .visit_union::<BotMessage, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          BotMessage::Identify => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Identify>>("BotMessage::Identify", pos),
          BotMessage::Ready => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Ready>>("BotMessage::Ready", pos),
          BotMessage::PreprocessingDone => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<PreprocessingDone>>("BotMessage::PreprocessingDone", pos),
          BotMessage::Action => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Action>>("BotMessage::Action", pos),
          BotMessage::Pong => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Pong>>("BotMessage::Pong", pos),
          BotMessage::Info => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Info>>("BotMessage::Info", pos),
          BotMessage::RenderCommands => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<RenderCommands>>("BotMessage::RenderCommands", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct BotPacketArgs {
            pub message_type: BotMessage,
            pub message: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for BotPacketArgs {
            #[inline]
            fn default() -> Self {
                BotPacketArgs {
                    message_type: BotMessage::NONE,
                    message: None,
                }
            }
        }

        pub struct BotPacketBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BotPacketBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message_type(&mut self, message_type: BotMessage) {
                self.fbb_.push_slot::<BotMessage>(
                    BotPacket::VT_MESSAGE_TYPE,
                    message_type,
                    BotMessage::NONE,
                );
            }
            #[inline]
            pub fn add_message(
                &mut self,
                message: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    BotPacket::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> BotPacketBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                BotPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<BotPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for BotPacket<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("BotPacket");
                ds.field("message_type", &self.message_type());
                match self.message_type() {
                    BotMessage::Identify => {
                        if let Some(x) = self.message_as_identify() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    BotMessage::Ready => {
                        if let Some(x) = self.message_as_ready() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    BotMessage::PreprocessingDone => {
                        if let Some(x) = self.message_as_preprocessing_done() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    BotMessage::Action => {
                        if let Some(x) = self.message_as_action() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    BotMessage::Pong => {
                        if let Some(x) = self.message_as_pong() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    BotMessage::Info => {
                        if let Some(x) = self.message_as_info() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    BotMessage::RenderCommands => {
                        if let Some(x) = self.message_as_render_commands() {
                            ds.field("message", &x)
                        } else {
                            ds.field(
                                "message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    },
                    _ => {
                        let x: Option<()> = None;
                        ds.field("message", &x)
                    },
                };
                ds.finish()
            }
        }
    } // pub mod protocol
} // pub mod pyrat
